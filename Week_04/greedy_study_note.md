### 贪心算法 (Greedy)
* 定义：贪心算法是一种在每一步选择中都采取在当前状态下最好或者最优（即最有利）的选择，从而希望导致结果
是全局最好或者最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能
回退。动态规划会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。
  * 贪心：当下做局部最优判断
  * 回溯：能够回退
  * 动态规划：最优判断 + 回退
* 用途： 贪心法可以解决一些最优化问题，如：求图中的最小生成树，求哈夫曼编码等。但是对于工程和生活中
的问题，贪心法一般不能得到我们所要的答案。
* 一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及
其所求的答案比较接近最优结果，贪心法可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

### 贪心法适用的场景
* 问题能够分成子问题来解决，子问题的最优解能递推到最终问题的最优解。
* 经典运用：
  * Huffman coding
  * Prim
  * Kruskal最小生成树
  * Dijkstra最短路径算法
  
### 贪心算法解决问题的步骤
1. 当我们看到这类问题的时候，首先要联想到贪心算法: 针对一组数据，我们定义了限制值和期望值，希望从中
选取几个数据，在满足限制值的情况下，期望值最大
2. 我们尝试看下这个问题是否可以用贪心算法解决: 每次选择当前的情况下，在对限制值同等贡献量的情况下，
对期望值贡献最大的数据。
3. 举例子验证看下贪心算法产生的结果是否是最优的: 大部分情况下，举几个例子验证一下就可以了。
严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，
大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。


### 实战题目
* [332. Coin Change](https://leetcode.com/problems/coin-change/)
  * 当硬币可选集合固定，例如 [20, 10, 5, 1]，用贪心法是可以找到最优解的 (因为选择里面都是可以整除
  的关系)，但是当硬币可选记变成 [10, 9, 1]的时候，贪心法就不一定适用了。
* [55. Jump Game](https://leetcode.com/problems/jump-game/)
  * [Python solution](./55_jump_game.py)
* [860. Lemonade Change](https://leetcode.com/problems/lemonade-change/)
  * [Python solution](./860_lemonade_change.py)
* [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/)
  * [Python solution](./122_best_time_to_buy_and_sell_stock_ii.py)